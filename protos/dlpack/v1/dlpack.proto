syntax = "proto3";

package dlpack.v1;

/*
 * The DLPack version.
 *
 * A change in major version indicates that we have changed the
 * data layout of the ABI - DLTensorVersioned.
 *
 * A change in minor version indicates that we have added new
 * code, such as a new device type, but the ABI is kept the same.
 *
 * In the case of a minor version mismatch, the tensor can be safely used as
 * long as the consumer knows how to interpret all fields. Minor version
 * updates indicate the addition of enumeration values.
 */
message DLPackVersion {
  // DLPack major version.
  uint32 major = 1;
  // DLPack minor version.
  uint32 minor = 2;
}

/*
 * A Device for Tensor and operator.
 */
message DLDevice {
  // The device type used in the device.
  int32 device_type = 1;
  /*
   * The device index.
   * For vanilla CPU memory, pinned memory, or managed memory, this is set to 0.
   */
  int32 device_id = 2;
}

/*
 * The data type the tensor can hold. The data type is assumed to follow the
 * native endian-ness. An explicit error message should be raised when attempting to
 * export an array with non-native endianness
 *
 *  Examples
 *   - float: type_code = 2, bits = 32, lanes = 1
 *   - float4(vectorized 4 float): type_code = 2, bits = 32, lanes = 4
 *   - int8: type_code = 0, bits = 8, lanes = 1
 *   - std::complex<float>: type_code = 5, bits = 64, lanes = 1
 *   - bool: type_code = 6, bits = 8, lanes = 1 (as per common array library convention, the underlying storage size of bool is 8 bits)
 */
message DLDataType {
  /*
   * Type code of base types.
   * We keep it uint8_t instead of DLDataTypeCode for minimal memory
   * footprint, but the value should be one of DLDataTypeCode enum values.
   * */
  uint32 code = 1;
  /*
   * Number of bits, common choices are 8, 16, 32.
   */
  uint32 bits = 2;
  //Number of lanes in the type, used for vector types.
  uint32 lanes = 3;
}

// Plain C Tensor object, does not manage memory.
message DLTensor {
  bytes data = 1;
  // The device of the tensor
  DLDevice device = 2;
  // Number of dimensions
  int32 ndim = 3;
  // The data type of the pointer
  DLDataType dtype = 4;
  // The shape of the tensor
  repeated int64 shape = 5;
  /*!
   * strides of the tensor (in number of elements, not bytes)
   *  can be NULL, indicating tensor is compact and row-majored.
   */
  repeated int64 strides = 6;
  // The offset in bytes to the beginning pointer to data
  uint64 byte_offset = 7;
}

/*
 * A versioned and managed C Tensor object, manage memory of DLTensor.
 *
 * This data structure is intended to facilitate the borrowing of DLTensor by
 * another framework. It is not meant to transfer the tensor. When the borrowing
 * framework doesn't need the tensor, it should call the deleter to notify the
 * host that the resource is no longer needed.
 *
 * \note This is the current standard DLPack exchange data structure.
 */
message DLTensorVersioned {
  // The API and ABI version of the current managed Tensor
  DLPackVersion version = 1;
  /*
   * Additional bitmask flags information about the tensor.
   *
   * By default the flags should be set to 0.
   */
  int64 flags = 2;
  DLTensor dl_tensor = 3;
}
